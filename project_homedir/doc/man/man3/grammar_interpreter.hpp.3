.TH "src/SLP_interpreter/grammar_interpreter.hpp" 3 "A simple tiger compiler" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/SLP_interpreter/grammar_interpreter.hpp \- realize of grammar  

.SH SYNOPSIS
.br
.PP
.SH "Detailed Description"
.PP 
realize of grammar 

Grammar atoms: stm, exp, expList, id, num, \&.\&.\&.
.br
 Grammar rules: A_compoundStm, A_assignStm, A_printStm, \&.\&.\&.
.br
 
.PP
.nf
* For example, grammar atoms ga have rules gr1, gr2, \&.\&.\&.
*  using A_ga = ptr to struct A_ga_
*  struct A_ga_:
*      field enum   ->  rules tokens
*      field union  ->  rules components
* constructo of rule:
*  auto A_gr(A_ga components \&.\&.\&.) -> pointer to struct A_ga;
* 
.fi
.PP
 
.SH "Typedef Documentation"
.PP 
.SS "using A_exp =  \fBA_exp_\fP *"

.SS "using A_expList =  \fBA_expList_\fP *"

.SS "using A_stm =  \fBA_stm_\fP *"
grammars was defined to type
.br
 for with data grammars, we use pointer to struct
.br
 for without data grammars, we use enum
.br
 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum A_binop"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIA_plus \fP\fP
.TP
\fB\fIA_minus \fP\fP
.TP
\fB\fIA_times \fP\fP
.TP
\fB\fIA_div \fP\fP
.SH "Function Documentation"
.PP 
.SS "\fBA_stm\fP A_AssignStm (\fBstring\fP id, \fBA_exp\fP exp)"

.SS "\fBA_stm\fP A_CompoundStm (\fBA_stm\fP stm1, \fBA_stm\fP stm2)"

.SS "\fBA_exp\fP A_EseqExp (\fBA_stm\fP stm, \fBA_exp\fP exp)"

.SS "\fBA_exp\fP A_IdExp (\fBstring\fP id)"

.SS "\fBA_expList\fP A_LastExpList (\fBA_exp\fP last)"

.SS "\fBA_exp\fP A_NumExp (int num)"

.SS "\fBA_exp\fP A_OpExp (\fBA_exp\fP left, \fBA_binop\fP oper, \fBA_exp\fP right)"

.SS "\fBA_expList\fP A_PairExpList (\fBA_exp\fP head, \fBA_expList\fP tail)"

.SS "\fBA_stm\fP A_PrintStm (\fBA_expList\fP exps)"

.SH "Author"
.PP 
Generated automatically by Doxygen for A simple tiger compiler from the source code\&.
